# Variables
variables:
# Name of the service connection
- name: sc_name
  value: 'sc-mg-coffeetimedev'
# ID of the subscription for the tfstate
- name: backend_subscription_id
  value: 'b34b291e-89b2-4d63-9f9c-1ac3e8f43b4f'
# Storage account to store the tfstate
- name: stg_name
  value: 'stterraformkprintz'
# RG name for the storage account to store the tfstate
- name: stg_rg_name
  value: 'rg-mgmt'
# Name of the container to store the tfstate
- name: stg_container_name
  value: 'terraform'

# Parameters
parameters:
# ID of the subscription for the deployment
- name: depl_subscription_id
  type: string 

# Stages
stages:
# Terraform plan
- stage: Plan
  # Use the a specific runner
  pool: azure-vm
  jobs:
  - job: Plan
    steps:
      # Checkout the repositories
      - checkout: self
        path: s/az-server
      - checkout: az-pipeline-template-tf-ansible

      # Init Terraform backend and download providers
      - task: TerraformCLI@0
        displayName: Terraform init
        inputs:
          workingDirectory: ./az-server/terraform
          command: init
          # Configure the backend to store the .tfstate file
          backendType: azurerm
          backendServiceArm: '${{ variables.sc_name }}'
          backendAzureRmSubscriptionId: '${{ variables.backend_subscription_id }}'
          backendAzureRmResourceGroupName: '${{ variables.stg_rg_name }}'
          backendAzureRmStorageAccountName: '${{ variables.stg_name }}'
          backendAzureRmContainerName: '${{ variables.stg_container_name }}'
          backendAzureRmKey: '$(System.TeamProject)/$(Build.Repository.Name).tfstate'

      # Plan Terraform ressources
      - task: TerraformCLI@0
        displayName: Terraform plan
        inputs:
          workingDirectory: ./az-server/terraform
          command: plan
          environmentServiceName: '${{ variables.sc_name }}'
          providerAzureRmSubscriptionId: '${{ parameters.depl_subscription_id }}'

# Terraform apply
- stage: Deploy
  # Use the a specific runner
  pool: azure-vm
  jobs:
  - job: Deploy
    steps:
      # Checkout the repositories
      - checkout: self
        path: s/az-server
      - checkout: az-pipeline-template-tf-ansible

      # Init Terraform backend and download providers
      - task: TerraformCLI@0
        displayName: Terraform init
        inputs:
          workingDirectory: ./az-server/terraform
          command: init
          # Configure the backend to store the .tfstate file
          backendType: azurerm
          backendServiceArm: '${{ variables.sc_name }}'
          backendAzureRmSubscriptionId: '${{ variables.backend_subscription_id }}'
          backendAzureRmResourceGroupName: '${{ variables.stg_rg_name }}'
          backendAzureRmStorageAccountName: '${{ variables.stg_name }}'
          backendAzureRmContainerName: '${{ variables.stg_container_name }}'
          backendAzureRmKey: '$(System.TeamProject)/$(Build.Repository.Name).tfstate'

      # Deploy Terraform ressources
      - task: TerraformCLI@0
        displayName: Terraform apply
        inputs:
          workingDirectory: ./az-server/terraform
          command: apply
          environmentServiceName: '${{ variables.sc_name }}'
          providerAzureRmSubscriptionId: '${{ parameters.depl_subscription_id }}'

# Ansible run
- stage: Config
  # Use the a specific runner
  pool: azure-vm
  jobs:
  # Check if we need to run Ansible
  - job: CheckConfig
    steps:
      # Checkout the repositories
      - checkout: self
        path: s/az-server
      - checkout: az-pipeline-template-tf-ansible

      # Check if we need to configure the VM
      - task: Bash@3
        displayName: Check VM config needed
        name: vm_config 
        inputs:
          targetType: 'inline'
          script: echo "##vso[task.setvariable variable=vm_config;isOutput=true;issecret=false]$(test -d "./az-server/ansibles" && echo true || echo false)" 

  # Run ansible
  - job: Config
    # Only run if there is an ansible folder
    condition: and(succeeded(), eq(dependencies.CheckConfig.outputs['vm_config'], 'true'))
    steps:
      # Checkout the repositories
      - checkout: self
        path: s/az-server
      - checkout: az-pipeline-template-tf-ansible

      # Init Terraform backend and download providers
      - task: TerraformCLI@0
        displayName: Terraform init
        inputs:
          workingDirectory: ./az-server/terraform
          command: init
          # Configure the backend to store the .tfstate file
          backendType: azurerm
          backendServiceArm: '${{ variables.sc_name }}'
          backendAzureRmSubscriptionId: '${{ variables.backend_subscription_id }}'
          backendAzureRmResourceGroupName: '${{ variables.stg_rg_name }}'
          backendAzureRmStorageAccountName: '${{ variables.stg_name }}'
          backendAzureRmContainerName: '${{ variables.stg_container_name }}'
          backendAzureRmKey: '$(System.TeamProject)/$(Build.Repository.Name).tfstate'

      # Get Terraform output
      - task: TerraformCLI@0
        displayName: Terraform output
        name: get_output 
        inputs:
          workingDirectory: ./az-server/terraform
          command: output
          environmentServiceName: '${{ variables.sc_name }}'
          providerAzureRmSubscriptionId: '${{ variables.depl_subscription_id }}'

      # Use ansible to configure the server
      - task: Ansible@0
        displayName: Configure the server
        inputs:
          ansibleInterface: 'agentMachine'
          playbookPathOnAgentMachine: './az-server/ansible/playbook.yml'
          failOnStdErr: false
          inventoriesAgentMachine: inlineContent
          inventoryInlineContentAgentMachine: |
            [packer]
            ${vm_ip_addr}
          args: --extra-vars "ansible_user=adminuser ansible_password=${vm_password}"
        env:
          vm_ip_addr: $(TF_OUT_VM_IP_ADDR)
          vm_password: $(TF_OUT_VM_SECRET)
          ANSIBLE_HOST_KEY_CHECKING: False
